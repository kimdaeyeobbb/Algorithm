# https://school.programmers.co.kr/learn/courses/30/lessons/92342
# 아이디어 - 비트마스크(BitMask) 알고리즘

def solution(n, info):  # n: 화살의 개수, info: 어피치가 맞춘 과녁 점수들
    answer = [0 for _ in range(11)]   # 라이언 - 0~10점 (11개)
    tmp = [0 for _ in range(11)]   # 임시로 라이언이 쏜 화살 정보 저장
    maxDiff = 0    # 라이언-어피치 최대 차이값 (최대값 찾으면 tmp값을 answer에 저장)

    for subset in range(1, 1<<10):
    # 각각의 경우의 수는 비트 표현 부분집합으로 나타냄 (1점~10점에 맞춤/못맞춤 -> 총 10칸이므로 2^10이용)
    # range(1, 1<<10): 1을 원소개의 개수만큼 왼쪽으로 shift (0~1023). 공집합 0은 라이언이 이길 수 없으므로 1부터 시작
        ryan = 0   # 라이언의 점수
        apeach = 0   # 어피치의 점수
        cnt = 0  # 라이언이 쏜 화살의 개수 (n을 넘어가면 안되고, n보다 화살을 더 쏜경우 나머지는 0점에 맞춘걸로 기록)

        # 여기서는 라이언의 점수를 계산합니다
        for i in range(10):
            # i번째 원소가 부분집합에 존재하는지 확인
            # 0~9번째 인덱스 -> 1점~10점에 대응
            if subset & (1 << i):
                # i번째에 해당하는 과녁을 라이언이 이기는 경우
                # subset에 i번쨰 원소존재 & 1을 i번만큼 왼쪽으로 shift (i번째 비트가 1로 켜짐) => subset에 i번째 비트가 켜져있는지 확인할 수 있음
                ryan += (10-i)   # 라이언이 받아야할 점수: 10-i  (i가 0일때 10점, i=1일때 9점 ...)
                tmp[i] = info[i] + 1   # (라이언이 최소개수차이로 이기기 위해서) 어피치보다 이 과녁에 1발 더 쏘면 됨 (info[i]+1)
                cnt +=  tmp[i]  # 라이언이 쏜 화살의 개수  -> tmp[i]를 누적해줌
            else:
                # 라이언이 이기지 못하는 경우
                tmp[i] = 0   # 이기지 못하므로 화살을 안쓰면 됨
                if info[i]:
                    # 어피치가 화살이 1개라도 있는경우 무조건 어피치가 이김
                    apeach += 10-i   # 어피치가 이기므로 어피치의 점수 올림


        # for문 종료 이후 - 이제 cnt에 라이언이 사용한 화살의 개수가 새겨져 있음

        if n < cnt:  # cnt가 n보다 크면 사용하면 안되는 부분집합이므로
            continue  # 버림

        tmp[10] = n - cnt   # n-cnt(총 써야하는 화살개수 -실제 과녁에 맞춘 화살개수 = 남은화살) => 0점에 남은화살 모두를 넣음

        # 라이언점수- 어피치점수가 최대차이값과 같은 경우 (가장 낮은 점수를 맞힌 개수가 같은 경우)
        if ryan-apeach == maxDiff:
            for i in reversed(range(11)):   # 10점부터 ~ 0점까지비교
                if tmp[i] > answer[i]:    # 같은 자리 비교- 가장 낮은 점수가 더 많이 맞춘 경우
                    maxDiff = ryan - apeach
                    answer = tmp[:]
                    break   #
                elif tmp[i] < answer[i]:   # answer가 더 큰 경우
                    break   # 업데이트할 필요가 없음

        elif ryan-apeach > maxDiff:
            # 라이언의 점수 - 어피치의 점수가 최대차이값 갱신하는 경우
            # 최초의 masDiff는 0으로 초기화했으므로 apeach가 이기는 경우는 모두 무시됨
            # 점수가 동일한 경우도 무시됨
            # 즉, 라이언이 이기는 경우만 해당되므로 이때만 최대 점수차이값 업데이트 대상임
            maxDiff = ryan - apeach   # 최대 점수차이값 갱신
            answer = tmp[:]   # answer에 라이언의 화살정보를 복사

    if maxDiff == 0:
        # 라이언이 못이기는 경우
        answer = [-1]

    return answer



'''
* 규칙
- 해당점수에서 이길 수 있을때는 1발만 더 쏴서 점수를 획득
- 화살을 1발을 더쏴서 이기나 2발을 더 써서 이기나 같으므로 1발만 더 쏘고 이기도록 함 (최소의 화살로 최대의 점수 획득하기 위함)
- 동률일 경우 질 수밖에 없으므로 1점씩 내려가며 체크
- 해당점수에서 이길 수 없는 경우 바로 밑의 점수로 내려가서 그 점수를 획득 (반복)
- 가장 큰 점수차로 우승할 수 있는 방법이 여러가지 일 경우, 가장 낮은 점수를 더 많이 맞춘 경우를 return
- 가장 낮은 점수를 맞힌 개수가 같은 경우 계속해서 그 다음으로 낮은 점수를 더 많이 맞힌 경우를 리턴


* 아이디어 - BitMask Algorithm

- 이진수를 사용하는 컴퓨터 연산 방식을 이용하여, 정수의 이진수 표현을 자료 구조로 사용하는 기법
- 이진수 => 0(꺼져있다), 1(켜져있다)를 이용하므로 1bit로 두가지를 표현할 수 있음
- 수행시간이 빠름 (bit 연산이므로 O(1)시간에 구현되는 것이 많음 => 연산 횟수가 늘어날 수록 유용) 
- 코드가 짧음 & 메모리 사용량이 적음





* 다른 아이디어 - BFS
- 너비 우선 탐색
그래프 내에 레이어/레벨로 구성된 이웃이 있을 경우, 적용할 수 있는 가장 효율적인 그래프 순회 전략
ex) 링크드인 회원 관계 네트워크는 a회원을 중심으로 1단계 커넥션, 2단계 커넥션... 과 같은 레이어로 구성

BFS는 루트노드에서 출발하여 인근 레이어의 노드들을 탐색함 -> 작업 종료시 그 다음 레이어의 노드 검색 과정 반복


- 구성요소
visited: 방문한 노드 저장 
queue: 다음 번 검색에서 방문할 노드를 저장 (리스트나 큐를 사용)


# BFS 구현
def bfs(graph,start):
    visited = []
    queue = [start]

    while queue:  # 큐에 내용물이 있는 동안 진행 (방문해야할 것이 남아있는 것)
        node = queue.pop(0)   # 큐에서 첫 번째 노드를 꺼내옴 (pop: 리스트의 맨 마지막요소, pop(x): 리스트의 x번째 요소 꺼내고 삭제)
        if node not in visited:  # 해당 노드를 방문하지 않았다면
            visited.append(node)   # 방문하고 표시
            neighbours = graph[node]   # 방문한 노드의 이웃노드를 불러옴
            for neighbour in neighbours:  # 불러온 이웃노드들을
                queue.append(neighbour)   # 큐에 추가
    return visited   # 모든 노드를 방문하고 나서 방문한 노드가 담긴 리스트 반환


* 소감
- 와 이문제는 어렵다. 몇시간을 썼는지 모르겠다 ㅠㅠ...
- 꼭 한번 다시 풀어봐야겠다
'''